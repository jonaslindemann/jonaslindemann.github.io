{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Coding thoughts","text":"<p>My name is Jonas Lindemann and I work in HPC where I teach coding in C++, Python and Fortran. I also develop HPC-related software packages (GfxLauncher, ARC Storage Explorer and much more). In my research, I developed several Structural Mechanics applications, primarily for use in conceptual design and teaching. </p> <p></p> <p>This blog is an attempt to open up my development process and thoughts to a wider audience and also encourage input. Recently I have started the process of modernizing several of my older applications and also rewriting them with new concepts and ideas. </p> <p>Welcome!</p> <p>Jonas Lindemann</p>"},{"location":"gen-links/","title":"General","text":"<p>Modern Fortran Book - Online Ingenj\u00f6rens guide till Python Min LU Profil</p>"},{"location":"gh-links/","title":"Projects","text":"<p>ObjectiveFrame Modern Fortran Book - Source Qt Creator Fortran extensions ForcePAD 3 - Development Lightray - 2D rendering library based on Raylib ForcePAD 2.x Ivf++ - Interactive Visualisation Framework - 3D Scenegraph library Ivf2 - Modern reimplementation of Ivf++ OO Fortran examples and lecture GFX Launcher Toolkit CALFEM for Python</p>"},{"location":"yt-links/","title":"Videos","text":"<p>My YouTube channel</p>"},{"location":"yt-links/#courses","title":"Courses","text":""},{"location":"yt-links/#introduction-to-scientific-computing-2024","title":"Introduction to Scientific Computing - 2024","text":""},{"location":"yt-links/#scientific-programming-in-python-and-fortran-2023","title":"Scientific Programming in Python and Fortran - 2023","text":""},{"location":"yt-links/#interactive-software","title":"Interactive Software","text":""},{"location":"yt-links/#lunarc","title":"LUNARC","text":""},{"location":"yt-links/#fortran","title":"Fortran","text":""},{"location":"blog/","title":"Blog","text":""},{"location":"blog/2025/01/12/the-fun-of-coding-3d-graphics-in-c-and-opengl/","title":"The fun of coding 3D graphics in C++ and OpenGL","text":"<p>There exist several 3D graphics libraries for C++ using OpenGL such as Raylib, OpenSceneGraph, VTK, Magnum, Cinder, OpenFrameworks and many more.</p> <p>There also game engines using C++ such as Unreal Engine, Godot, CryEngine, Lumberyard and more.</p> <p>However, my needs for 3d programming have not been for games but for interactive 3d applications mainly in the field of engineering. I have used OpenGL for many years. For my PhD I developed a 3D Scene Graph library, Ivf++, which was a wrapper around OpenGL. It contained a set of nodes for implementing interactive 3D applications, such as ObjectiveFrame a 3D beam analysis application focusing on real-time interaction. </p> <p>During the last decade OpenGL has evolved and the fixed function pipeline has been deprecated. Modern OpenGL is based on shaders and the programmable pipeline. This has made OpenGL more powerful, but with the cost of complexity and ease of use. This article is about my journey implementing a new 3D graphics library for C++ that is easy to use and at the same time flexible. Ultimately I want to get back to ease of use of the fixed function pipeline but with the power of modern OpenGL.</p> <p>In an effort to learn modern OpenGL I started to reimplement the Ivf++ library using modern shader based OpenGL. I didn't want to refactor the original library as it is used in ObjectiveFrame, so I decided to create a new library from scratch, ivf2. At a high level I wanted to remove as many obstacles as possible programming 3D graphics applications in C++. The library should be easy to use and at the same time powerful. Also, it should be fun to create 3D applications in C++. Perhaps I will use it for creative coding at some point in the future.</p>"},{"location":"blog/2025/01/12/the-fun-of-coding-3d-graphics-in-c-and-opengl/#design-goals","title":"Design goals","text":"<p>As the library is a work in progress, the design goals are not yet fully realized and will probarbly change over time. However, the following are some of the goals I have in mind:</p> <ul> <li>Easy to use - consistent syntax and API that is easy to understand)</li> <li>Modern OpenGL - support modern OpenGL features</li> <li>Scene Graph - main focus of rendering is the scene graph</li> <li>Rich set of primitives - support for common 3D primitives</li> <li>Interactive - support for easy interaction with the 3D scene</li> <li>Built-in window support (GLFW) - it should be easy to create a window in the library</li> <li>Build-in GUI support (ImGui) - immediate mode GUI for easy interaction with the application</li> <li>Fully object-oriented - use of classes and objects for easy programming</li> <li>Robust - shared and unique pointer support</li> <li>Built-in stock shaders - no need to implement shaders for simple applications</li> <li>Post processing effects - built-in support for post processing effects</li> </ul>"},{"location":"blog/2025/01/12/the-fun-of-coding-3d-graphics-in-c-and-opengl/#the-journey-starts","title":"The journey starts","text":"<p>The first steps in implementing the library was to create a flexible infrastructure compiling and linking shaders and keeping track of these. Shaders support in ivf2 is implemented in number of classes:</p> <ul> <li>Shader - a class for loading and compiling a shader. </li> <li>Program - a class for linking shaders into a program. </li> <li>ShaderManager - a class for managing shaders and programs.</li> </ul> <p>The Shader class can load shaders from file and from strings. The built-in stock shaders are loaded from strings that are included from . The Program class links shaders into a program. The class also provides an interface to the shader uniforms. The following example shows how to create a simple shader program:</p> <pre><code>#include &lt;ivf/vertex_shader.h&gt;\n#include &lt;ivf/fragment_shader.h&gt;\n#include &lt;ivf/program.h&gt;\n#include &lt;ivf/stock_shaders.h&gt;\n\nint main() \n{\n    // Initialization\n\n    auto vertexShader = VertexShader::create(ivf::basic_vert_shader_source);\n    auto fragmentShader = FragmentShader::create(ivf::basic_frag_shader_source);\n\n    auto program = Program::create();\n\n    program.addShader(vertexShader);\n    program.addShader(fragmentShader);\n\n    if (!program.link())\n    {\n        std::cout &lt;&lt; \"Failed to compile and link program.\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n        // Main game loop\n\n    while (!WindowShouldClose()) \n    {\n        // Draw\n\n        program-&gt;use();\n        program-&gt;uniformFloat(\"time\", GetTime());\n        // Draw something\n    }\n\n    // De-Initialization\n\n    return 0;\n}\n</code></pre> <p>To make it even easier to load and manage shaders a special singleton class ShaderManager is used. The ShaderManager class is a singleton class that manages shaders and programs. The shader manager implements methods for directly loading and compiling shaders to named programs. The following example shows how to create a simple shader program using the ShaderManager:</p> <pre><code>#include &lt;ivf/shader_manager.h&gt;\n#include &lt;ivf/stock_shaders.h&gt;\n\nint main() \n{\n    // Initialization\n\n    auto shaderManager = ShaderManager::getInstance();\n    auto program = shaderManager-&gt;loadProgram(\"basic\", ivf::basic_vert_shader_source, ivf::basic_frag_shader_source);\n\n    if (shaderManager-&gt;compileLinkErrors())\n    {\n        std::cout &lt;&lt; \"Failed to compile and link program.\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n    // Main game loop\n\n    while (!WindowShouldClose()) \n    {\n        // Draw\n\n        program-&gt;use();\n        program-&gt;uniformFloat(\"time\", GetTime());\n        // Draw something\n    }\n\n    // De-Initialization\n\n    return 0;\n}\n</code></pre> <p>Compiled programs can be convieniently accessed by name using the ShaderManager. </p> <pre><code>// Get named program\n\nauto program = shaderManager-&gt;program(\"basic\");\n\n// The the current program\n\nshaderManager-&gt;setCurrentProgram(\"basic\");\n\nauto program = shaderManager-&gt;currentProgram();\n</code></pre>"},{"location":"blog/2025/01/12/the-fun-of-coding-3d-graphics-in-c-and-opengl/#not-calling-new-and-delete","title":"Not calling new and delete...","text":"<p>One major goal of the library was to be able to use shared and unique pointers for managing objects. This means that you don't have to call new and delete for creating objects. The library is fully object-oriented and uses shared and unique pointers for managing objects. </p> <p>To support shared pointers and also supporting new users I decided that all classes implemented by the library should have a static create method, which can be called to create an object. By combining this with the auto keyword in C++11, the code becomes very clean and easy to read. The following example shows how to create a shared pointer to a ivf::Cylinder object:</p> <pre><code>using namespace ivf;\n\nauto cylinder = Cylinder::create(1.0, 1.0, 32);\n</code></pre> <p>The create method is a static method that returns a shared pointer to the object. The object is automatically deleted when the last shared pointer goes out of scope.</p> <p>The syntax of using a create() method is heavily inspired by Object Pascal and Delphi. I have used Delphi for many years and I like the syntax of creating objects in Delphi.</p> <p>To make it easier for new users of the library, all classes also defined a typedef for a shared pointer to the object. This means that you can use the typedef to create a shared pointer to the object. The following example shows how to create a shared pointer to a ivf::Cylinder object using the typedef:</p> <pre><code>using namespace ivf;\n\nCylinderPtr cylinder = Cylinder::create(1.0, 1.0, 32);\n\n// Equivalent to\n// std::shared_ptr&lt;Cylinder&gt; cylinder = std::make_shared&lt;Cylinder&gt;(1.0, 1.0, 32);\n</code></pre> <p>As the library heavily relies on Polymorphism, using shared pointers is a natural choice. The library is designed to be used with shared pointers and the library itself uses shared pointers for managing objects.</p>"},{"location":"blog/2025/01/12/the-fun-of-coding-3d-graphics-in-c-and-opengl/#the-scene-graph","title":"The Scene Graph","text":"<p>The scene graph in ivf2 is based on 2 main classes Node and CompositeNode. The Node class is the base class for all nodes in the scene graph. The CompositeNode class is a node that can contain other nodes. The scene graph is a tree structure where each node can have a parent and children. The scene graph is traversed in a depth-first manner. The following example shows how to create a simple scene graph:</p> <pre><code>#include &lt;ivf/gl.h&gt;\n#include &lt;ivf/nodes.h&gt;\n\nint main() \n{\n    // ...\n\n    auto scene = CompositeNode::create();\n    auto cube = Cube::create();\n    auto sphere = Sphere::create();\n\n    scene-&gt;add(cube);\n\n    // ...\n\n    scene-&gt;draw();\n\n    // ...\n\n    return 0;\n}\n</code></pre> <p>Most primitive classes derive from the TransformNode class which provides basic transformation functionality. The TransformNode class is a node that can be transformed using translation, rotation and scaling. The following example shows how to create a simple scene graph with a transformed cube:</p> <pre><code>auto scene = CompositeNode::create();\nauto cube = Cube::create();\nauto sphere = Sphere::create();\n\ncube-&gt;setPos(glm::vec3(0.0, 1.0, 0.0));\nsphere-&gt;setPos(glm::vec3(1.0, 0.0, 0.0));\n</code></pre>"},{"location":"blog/2025/01/12/the-fun-of-coding-3d-graphics-in-c-and-opengl/#meshnode-and-primitives","title":"MeshNode and primitives","text":"<p>I realised the time for immediate mode rendering is over. The library is based on modern OpenGL and uses Vertex Buffer Objects (VBO) and Vertex Array Objects (VAO) for rendering. The MeshNode class implements the functionality for rendering creating meshes using VBOs and VAOs using a simple interface similar to the fixed function pipeline. To implement a mesh, a derived class overrides the doSetup method of the MeshNode-class. The following example shows how the Cube class implements its mesh:</p> <pre><code>void Cube::doSetup()\n{\n    //   y  o--------o\n    //   ^ /|       /| \n    //   |/ |     2/ |\n    //  3o--------o  |\n    //   |  o-----|--o \n    //   | /      | / \n    //   |/       |/\n    //   o--------o --&gt; x\n    //   0        1\n\n    double n = m_size/2.0;\n\n    mesh()-&gt;begin(GL_TRIANGLES);\n    mesh()-&gt;vertex3d(-n, -n, n);\n    mesh()-&gt;color3f(1.0f, 0.0f, 0.0f);\n    mesh()-&gt;vertex3d(n, -n, n);\n    mesh()-&gt;color3f(1.0f, 0.0f, 1.0f);\n    mesh()-&gt;vertex3d(n, n, n);\n    mesh()-&gt;color3f(1.0f, 1.0f, 0.0f);\n    mesh()-&gt;vertex3d(-n, n, n);\n    mesh()-&gt;color3f(1.0f, 1.0f, 1.0f);\n\n    mesh()-&gt;index3i(0, 1, 2); // front\n    mesh()-&gt;index3i(0, 2, 3);\n\n    mesh()-&gt;vertex3d(-n, -n, -n);\n    mesh()-&gt;color3f(0.0f, 0.0f, 1.0f);\n    mesh()-&gt;vertex3d(n, -n, -n);\n    mesh()-&gt;color3f(0.0f, 1.0f, 0.0f);\n    mesh()-&gt;vertex3d(n, n, -n);\n    mesh()-&gt;color3f(0.0f, 1.0f, 1.0f);\n    mesh()-&gt;vertex3d(-n, n, -n);\n    mesh()-&gt;color3f(1.0f, 0.0f, 0.0f);\n\n    mesh()-&gt;index3i(4, 6, 5); // back\n    mesh()-&gt;index3i(4, 7, 6);\n\n    // ...\n\n    mesh()-&gt;end();\n}\n</code></pre> <p>I also realised that implementing all primitives in the library would be a huge task. To solve this I search the internet and github for a solution to this problem. What I found was a geometry generator called Generator. It is a header only library that can generate most basic primitives shapes that can be used in 3D graphics. Most of the primitives in ivf2 are implemented using the Generator library. The following example shows how to create a sphere using the Generator library:</p> <pre><code>// ...\n\nvoid Sphere::doSetup()\n{\n    SphereMesh sphere(m_radius, m_slices, m_segments, m_sliceStart, m_sliceSweep, m_segmentStart, m_segmentSweep);\n\n    AnyGenerator&lt;MeshVertex&gt; vertices = sphere.vertices();\n    AnyGenerator&lt;Triangle&gt; triangles = sphere.triangles();\n\n    this-&gt;createFromGenerator(vertices, triangles);\n}\n\n// ...\n</code></pre> <p>To support generating geometry using this library the MeshNode class implements a special method createFromGenerator that can create a mesh from a generator. The createFromGenerator method takes two generators, one for vertices and one for triangles. </p>"},{"location":"blog/2025/01/12/the-fun-of-coding-3d-graphics-in-c-and-opengl/#lights-materials-and-textures","title":"Lights, materials and textures","text":"<p>To recreate an environment similar to the fixed function pipeline, ivf2 comes with built-in support for lights, materials and textures. The Light class implements a light source that can be used in the scene. The Material class implements a material that can be used to set the material properties of an object. The Texture class implements a texture that can be used to texture an object. The following example shows how to create a light, material and texture:</p> <pre><code>auto shaderMgr = ShaderManager::create();\n\n// Load our basic shader\n\nshaderMgr-&gt;loadBasicShader();\n\n// Lights are managed by the LightManager\n\nauto lightMgr = LightManager::create();\n\n// Add a point light\n\nauto pointLight1 = lightMgr-&gt;addPointLight();\npointLight1-&gt;setEnabled(true);\npointLight1-&gt;setDiffuseColor(glm::vec3(1.0, 1.0, 1.0));\npointLight1-&gt;setSpecularColor(glm::vec3(1.0, 1.0, 1.0));\npointLight1-&gt;setAttenuation(1.0, 0.0, 0.0);\npointLight1-&gt;setPosition(glm::vec3(5.0, 5.0, 5.0));\n\n// Update the shader\n\nlightMgr-&gt;apply();\n\n// Create a material\n\nauto material = Material::create();\nmaterial-&gt;setDiffuseColor(glm::vec4(random(0.0, 1.0), random(0.0, 1.0), random(0.0, 1.0), 1.0));\nmaterial-&gt;setAmbientColor(glm::vec4(0.1, 0.1, 0.1, 1.0));\n\n// Create a sphere with an attached material\n\nauto sphere = Sphere::create();\nsphere-&gt;setMaterial(material);\n\n// ...\n</code></pre> <p>Textures can also be attached to nodes in the scene graph. The Texture class implements a texture that can be used to texture an object. The following example shows how to create a texture and attach it to a node:</p> <pre><code>auto textureCat = Texture::create();\ntextureCat-&gt;load(\"assets/pop_cat.png\");\n\nauto textureBrick = Texture::create();\ntextureBrick-&gt;load(\"assets/brick.png\");\n\nauto sphere = Sphere::create();\nsphere-&gt;setTexture(textureCat);\nsphere-&gt;setMaterial(sphereMaterial);\nsphere-&gt;setPos(glm::vec3(0.0, 3.0, 0.0));\n\nauto box = Box::create();\nbox-&gt;setTexture(textureBrick);\nbox-&gt;setMaterial(sphereMaterial);\nbox-&gt;setPos(glm::vec3(3.0, 0.0, 0.0));\n</code></pre>"},{"location":"blog/2025/01/12/the-fun-of-coding-3d-graphics-in-c-and-opengl/#windows-and-gui","title":"Windows and GUI","text":"<p>To make it easy to create a window and GUI in the library, ivf2 comes with built-in support for GLFW and ImGui in the ivfui-library. Window support in ivf2 is implemented using the GLFW library encapsulated in GLFWApplication, GLFWWindow and GLFWSceneWindow classes. The Application class is a singleton class that manages GLFW windows and the rendering contexts. The following examples illustrates a versy simple ivf2 GLFW application:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include &lt;vector&gt;\n\n#include &lt;ivfui/glfw_application.h&gt;\n#include &lt;ivfui/glfw_window.h&gt;\n\n#include &lt;ivf/gl.h&gt;\n#include &lt;ivf/nodes.h&gt;\n#include &lt;ivfui/ui.h&gt;\n\nusing namespace ivf;\nusing namespace ivfui;\nusing namespace std;\n\nclass ExampleWindow : public GLFWWindow {\nprivate:\n    CompositeNodePtr m_scene;\n    CameraManipulatorPtr m_camManip;\n\npublic:\n    ExampleWindow(int width, int height, std::string title) : GLFWWindow(width, height, title)\n    {}\n\n    static std::shared_ptr&lt;ExampleWindow&gt; create(int width, int height, std::string title)\n    {\n        return std::make_shared&lt;ExampleWindow&gt;(width, height, title);\n    }\n\n    int onSetup()\n    {\n        // Setup the scene\n\n        auto shaderMgr = ShaderManager::create();\n        shaderMgr-&gt;loadBasicShader();\n\n        auto lightMgr = LightManager::create();\n\n        auto pointLight1 = lightMgr-&gt;addPointLight();\n        pointLight1-&gt;setEnabled(true);\n        pointLight1-&gt;setDiffuseColor(glm::vec3(1.0, 1.0, 1.0));\n        pointLight1-&gt;setSpecularColor(glm::vec3(1.0, 1.0, 1.0));\n        pointLight1-&gt;setAttenuation(1.0, 0.0, 0.0);\n        pointLight1-&gt;setPosition(glm::vec3(5.0, 5.0, 5.0));\n        lightMgr-&gt;apply();\n\n        m_scene = CompositeNode::create();\n\n        auto axis = Axis::create();\n\n        m_scene-&gt;add(axis);\n\n        // Create more nodes ...\n\n        m_scene-&gt;add(node);\n\n        m_camManip = CameraManipulator::create(this-&gt;ref());\n\n        return 0;\n    }\n\n    void onDraw()\n    {\n        // This method is called continuously to draw the scene\n\n        glClearColor(0.07f, 0.13f, 0.17f, 1.0f);\n        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n        // Update the camera manipulator\n\n        m_camManip-&gt;update();\n\n        // Draw the scene\n\n        m_scene-&gt;draw();\n    }\n\n    void onResize(int width, int height)\n    {\n        // This method is called when the window is resized\n\n        m_camManip-&gt;update();\n    }\n};\n\ntypedef std::shared_ptr&lt;ExampleWindow&gt; ExampleWindowPtr;\n\nint main()\n{\n    // Create application object\n\n    auto app = GLFWApplication::create();\n\n    // Set context hints\n\n    app-&gt;hint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n    app-&gt;hint(GLFW_CONTEXT_VERSION_MINOR, 3);\n    app-&gt;hint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n    app-&gt;hint(GLFW_SAMPLES, 4);\n\n    // Create a window\n\n    auto window = ExampleWindow::create(800, 800, \"Example 1\");\n    window-&gt;maximize();\n\n    // Add the window to the application\n\n    app-&gt;addWindow(window);\n\n    // Run the application\n\n    return app-&gt;loop();\n}\n</code></pre> <p>The final rendered window could look something like this:</p> <p></p>"},{"location":"blog/2025/01/12/the-fun-of-coding-3d-graphics-in-c-and-opengl/#how-can-you-try-ivf2","title":"How can you try ivf2?","text":"<p>The library is still in development and not yet ready for release. However, you can try the library by cloning the repository from https://github.com/jonaslindemann/ivf2. Build instruction are available in the README.md file in the repository.</p>"},{"location":"blog/2025/01/12/the-fun-of-coding-3d-graphics-in-c-and-opengl/#getting-involved","title":"Getting involved","text":"<p>If you are interested in the project and want to get involved, my contact information is here: Jonas Lindemann</p>"},{"location":"blog/2024/07/19/a-new-backend-for-forcepad/","title":"A new backend for ForcePAD","text":"<p>The current version of ForcePAD is implemented using the FLTK library and OpenGL for graphics. At the time FLTK provided an easy way of implementing an multiplatform application that could run on Windows and Unix/Linux. FLTK provided both an intuitive environment for designing the 2D user interface as well as easy OpenGL context creation. OpenGL context creation on Windows and Unix was implemented very differently on each platform. Having just one way of this enabled ForcePAD to be implemented in a single code base.</p> <p>Using FLTK and OpenGL today has been more problematic. Even though context creation in FLTK is still easy. It is not very flexible preventing new modern OpenGL features from being easily implemented. Also, OpenGL today is a fragmented environment. Apple and macOS are currently not supporting the library and put restrictions on which versions they make available. At this point, I was a bit depressed about the lack of standards in graphics APIs. After I saw a YouTube video on game engines I was impressed with the game library RayLib (https://www.raylib.com/. </p> <p></p> <p>Raylib is a modular game engine that is available on all platforms. When compared to other game engines, Raylib is more of a toolbox where you can use what you need. This is very much the same experience I had with OpenGL a long time ago. The API provides both low-level functions as well as more high-level functions. An example of a very simple RayLib application is shown below:</p> <pre><code>#include \"raylib.h\"\n\nint main() \n{\n    // Initialization\n\n    int screenWidth = 800;\n    int screenHeight = 450;\n\n    InitWindow(screenWidth, screenHeight, \"Simple RayLib Example\");\n\n    SetTargetFPS(60); // Set our game to run at 60 frames-per-second\n\n    // Main game loop\n\n    while (!WindowShouldClose()) \n    {\n        // Draw\n\n        BeginDrawing();\n        ClearBackground(RAYWHITE);\n        DrawText(\"This is RayLib\", 190, 200, 20, LIGHTGRAY);\n        EndDrawing();\n    }\n\n    // De-Initialization\n\n    CloseWindow(); \n\n    return 0;\n}\n</code></pre> <p>This application will compile for any supported platform, which currently are:</p> <ul> <li>Windows</li> <li>Linux</li> <li>macOS</li> <li>iOS</li> <li>Android</li> <li>Raspberry Pi</li> <li>HTML5</li> </ul> <p>This also means that from the same source code, I can build a native application as well as an application that can be run directly on a web page using web assembly.</p> <p>In the following blog posts, I will try to describe how I set up the basic project and implement the basic abstractions for the application.</p> <p>Until the next blog post...</p>"},{"location":"blog/2024/08/14/building-for-many-platforms-is-hard/","title":"Building for many platforms is hard","text":"<p>Choosing the right libraries for your application is just one step in making it run on multiple operating systems. ForcePAD uses CMake to build the application on multiple platforms. CMake is an excellent tool that generates build files for each platform. On Windows it generates Visual Studio solution files. On other platform it generates make files. I started implementing most of the tooling for ForcePAD on Windows thinking that most of this can be easily transferred to macOS. This what not that easy. I will go through the setup in the following sections.</p>"},{"location":"blog/2024/08/14/building-for-many-platforms-is-hard/#windows-and-dependencies","title":"Windows and dependencies","text":"<p>The biggest issue with building applications on Windows is the dependencies that on many other operating systems such as Linux are easily installable using a package manager. Until recently there was no real packages manager available on Windows, requiring you to download, build and install dependencies manually. Today there are several package managers for C++ that can solve this problem, such as Conan and Vcpkg. For ForcePAD I chose to use Vcpkg as it has worked well for other projects. To use Vcpkg you provide a vcpkg.json file in your root build directory. In this file you specify the dependencies you have in your project. An example of this is shown below:</p> <pre><code>{\n    \"name\": \"forcepad\",\n    \"version\": \"0\",\n    \"dependencies\":\n    [\n        {\n            \"name\": \"raylib\",\n            \"platform\": \"windows\"\n        },\n        {\n            \"name\": \"opengl\",\n            \"platform\": \"windows\"\n        },    \n        {\n            \"name\": \"eigen3\",\n            \"platform\": \"windows\"\n        },\n        \"stb\",\n        {\n            \"name\": \"imgui\",\n            \"features\": [\"docking-experimental\"]\n        },\n        {\n            \"name\": \"glfw3\",\n            \"platform\": \"windows\"\n        }\n    ]\n}\n</code></pre> <p>The important stuff is contained in the dependencies section. Here you list the packages you require. The platform attributes indicates for which platform this dependency is required. It is optional, but I will come back to this later. To build the dependencies you type:</p> <pre><code>C:\\...\\&gt;vcpkg install\n</code></pre> <p>This will build the dependencies in your current directory. By default build libraries will be placed in the vcpkg_installed directory. </p> <p>To make sure these libraries are found by CMake we need to define a CMakePresets.json file where we specify where Vcpkg can be found for the different platforms. The preset file for ForcePAD is shown below:</p> <pre><code>{\n  \"version\": 3,\n  \"configurePresets\": [\n    {\n      \"name\": \"default\",\n      \"toolchainFile\": \"e:/vcpkg/scripts/buildsystems/vcpkg.cmake\"\n    },\n    {\n      \"name\": \"linux\",\n      \"toolchainFile\": \"/home/bmjl/vcpkg/scripts/buildsystems/vcpkg.cmake\"\n    },\n    {\n      \"name\": \"macos\",\n      \"toolchainFile\": \"/Users/lindemann/vcpkg/scripts/buildsystems/vcpkg.cmake\"\n    }\n  ]\n}\n</code></pre>"},{"location":"blog/2024/08/14/building-for-many-platforms-is-hard/#a-cmakeliststxt-file-for-all-platforms","title":"A CMakeLists.txt file for all platforms","text":"<p>The nice thing using a package manager is that the actual CMakeLists.txt file doesn't have to have explicit paths for different libraries. Normal find_package(...) commands can be called and corresponding paths will be found. The commands used to find the packages are the following:</p> <pre><code>find_package(raylib CONFIG REQUIRED)\nfind_package(Eigen3 CONFIG REQUIRED)\nfind_package(imgui CONFIG REQUIRED)\nfind_package(OpenGL REQUIRED)\nfind_package(Stb REQUIRED) \nfind_package(glfw3 CONFIG REQUIRED)\n</code></pre>"},{"location":"blog/2024/08/14/building-for-many-platforms-is-hard/#configuring-and-building-with-cmake","title":"Configuring and building with CMake","text":"<p>To configure a debug build of ForcePAD using the default preset CMake is called with the following command line:</p> <pre><code>C:\\...\\&gt;cmake -B build-debug -DCMAKE_BUILD_TYPE=Debug --preset default\n</code></pre> <p>This configures the ForcePAD debug build in the build-debug directory. Building ForcePAD can now be done using the following command:</p> <pre><code>C:\\...\\&gt;cmake --build build-debug --config Debug -- /m\n</code></pre> <p>It is of course possible to use Visual Studio solution files contained in the build-debug directory to edit and build ForcePAD.</p>"},{"location":"blog/2024/08/14/building-for-many-platforms-is-hard/#multiplatform-is-still-hard","title":"Multiplatform is still hard","text":"<p>At this point I was very happy to have build system that at least in theory should work on both Windows and macOS. I copied over all my source files to my newly aquired Mac mini. Installed all development tools and MacBrew. </p> <p>I ran the same commands and Vcpkg started to build the dependencies, but the compiler and linker errors where plenty. I realised that using the Apple provided g++ compiler was not a good choice, so I switched to the brew provided compilers g++-13/gcc-13. This required me to make sure that they where used instead of the Apple-compilers. Using the following statements I set the required environment variables so that CMake and Vcpkg picked up the right compilers:</p> <pre><code>export CXX=g++-13\nexport CC=gcc-13\n</code></pre> <p>This reduced some of the compiler errors, but I still got a lot of linker errors with Vcpkg build libraries. Then I had an idea. Perhaps I should use brew to provide some of the packages instead. I added the platform directive in the vcpkg.json file and I told vcpkg only to build raylib, opengl, eigen3 and glfw3 on Windows. This make a lot of errors go away. However I got stuck on missing system libraries from Apple such as CoreGraphics and Cocoa. I modified my CMakeLists.txt for the main ForcePAD executable to the following:</p> <pre><code>if (CMAKE_BUILD_TYPE STREQUAL \"Debug\")\n    if (APPLE)\n        add_executable(forcepad3d main.cpp forcepad_window.cpp forcepad_window.h)\n        target_include_directories(forcepad3d PRIVATE ${gui_INCLUDE_DIRS} ${raylib_INCLUDE_DIRS})\n        target_link_libraries(forcepad3d PRIVATE \"-framework CoreGraphics\" \"-framework Cocoa\" \"-framework IOKit\" \"-framework OpenGL\" \"-framework CoreFoundation\" rlimguid guid graphicsd ${raylib_LIBRARIES} OpenGL::GL imgui::imgui glfw)\n    else()\n        ...\n</code></pre> <p>These changes made ForcePAD build on macOS and worked on first startup. To make configuration a bit I created a build.cmd on Windows and a build.sh on macOS to automate some of the steps.</p>"},{"location":"blog/2024/08/14/building-for-many-platforms-is-hard/#conclusions","title":"Conclusions","text":"<p>Building a multiplatform application is hard. Raylib made it a bit easier on the source level, but still requires dependencies on the system side. It also worries me a bit that Raylib relies on OpenGL, which is kind of unsupported on macOS, but I suspect the Raylib developers could do some port of the rlgl to metal or other libraries.</p>"},{"location":"blog/2024/09/09/calfem-for-python-3610-released/","title":"CALFEM for Python 3.6.10 released","text":"<p>CALFEM for Python is a comprehensive package designed for learning the finite element method. Originally developed in the 1980s using Fortran, CALFEM has since evolved to support MATLAB and Python. The Python version was specifically created to facilitate the course \"Software Development for Technical Applications\" at Structural Mechanics in Lund. Throughout the course, students gain hands-on experience in developing a complete finite element application in Python. They learn how to implement various components, including mesh generation, solver, user interface, and visualization routines.</p> <p>In this blog post, I will provide a detailed explanation of the packaging and installation process for CALFEM.</p>"},{"location":"blog/2024/09/09/calfem-for-python-3610-released/#distributing-and-packaging-calfem-for-python","title":"Distributing and packaging CALFEM for Python","text":"<p>The early versions of CALFEM for Python were distributed by placing all the Python source code files in a zip-archive and linking it on Structural Mechanics web pages. However, this approach proved to be cumbersome. In 2009, we transitioned to using Subversion as a source repository for better development tracking. In recent years, we have migrated all our development efforts to GitHub.</p> <p>Using a source repository allowed us to tag released versions and provide links to the latest version of CALFEM on our web pages. However, even with this improvement, the process of installing the package and setting the PYTHONPATH still required manual installation of all the dependencies. To address this issue, I modified the repository to create a package called calfem-python using setuptools in Python. This involved creating a special setup.py script in the source directory, which is used to generate the packages. The generated tar files are then uploaded to PyPI using specific commands.</p>"},{"location":"blog/2024/09/09/calfem-for-python-3610-released/#creating-packages-with-pdm","title":"Creating packages with PDM","text":"<p>Releasing packages in the traditional way can be unnecessarily complicated. Fortunately, there are several packaging tools available that simplify the package creation process. One such tool is PDM (Python Package and Dependency Manager), which I recently discovered and found to be incredibly user-friendly.</p> <p>To utilize PDM, you'll need to make some modifications to your source tree. In the case of the calfem-python package, all source modules were initially located in the calfem directory within the source tree. However, PDM requires all source files to be placed under the src directory, as demonstrated below.</p> <pre><code>\u251c\u2500\u2500\u2500src\n\u2502   \u2514\u2500\u2500\u2500calfem\n</code></pre> <p>To use PDM in your source tree you run pdm init the first time. This will ask you a number of questions and generate a pyproject.toml file. The pyproject.toml file of the calfem-python is shown below:</p> <p>First we define the main project attributes such as package-name and version.</p> <pre><code>[project]\nname = \"calfem-python\"\nversion = \"3.6.10\"\ndescription = \"CALFEM for Python\"\nauthors = [\n    {name = \"Jonas Lindemann\", email = \"jonas.lindemann@lunarc.lu.se\"},\n    {name = \"Jonas Lindemann\", email = \"jonas.lindemann@gmail.com\"},\n]\n</code></pre> <p>Next we need to specify the hard dependencies of the package:</p> <pre><code>dependencies = [\n    \"gmsh\",\n    \"matplotlib\",\n    \"numpy\",\n    \"scipy\",\n    \"tabulate\",\n]\n\nrequires-python = \"&gt;=3.8\"\n</code></pre> <p>In the following part we specify some package metadata such as README files, license type and keywords.</p> <pre><code>readme = \"README.md\"\nlicense = {text = \"MIT\"}\nkeywords = [\n    \"finite element\",\n    \"math\",\n    \"numerics\",\n]\n</code></pre> <p>In the classifiers section we give some additional project metadata.</p> <pre><code>classifiers = [\n    \"Development Status :: 4 - Beta\",\n    \"Intended Audience :: Developers\",\n    \"License :: OSI Approved :: MIT License\",\n    \"Programming Language :: Python :: 3\",\n    \"Programming Language :: Python :: 3.10\",\n    \"Programming Language :: Python :: 3.11\",\n    \"Programming Language :: Python :: 3.12\",\n    \"Programming Language :: Python :: 3.7\",\n    \"Programming Language :: Python :: 3.8\",\n    \"Programming Language :: Python :: 3.9\",\n    \"Topic :: Software Development :: Build Tools\",\n]\n</code></pre> <p>We can also provide a linke to a project home page.</p> <pre><code>[project.urls]\nHomepage = \"https://github.com/CALFEM/calfem-python\"\n</code></pre> <p>The pyproject.toml file is a standardised build file used by many build systems. To specify that this package requires PDM we specify this in the build-system secion.</p> <pre><code>[build-system]\nrequires = [\"pdm-backend\"]\nbuild-backend = \"pdm.backend\"\n\n[tool.pdm]\ndistribution = true\n</code></pre> <p>Finally we list any optional dependencies.</p> <pre><code>[project.optional-dependencies]\nvisvis = [ \"visvis\" ]\nvedo = [ \"vedo\" ]\npyvtk = [ \"pyvtk\" ]\nqtpy = [ \"qtpy\" ]\n</code></pre>"},{"location":"blog/2024/09/09/calfem-for-python-3610-released/#creating-the-package","title":"Creating the package","text":"<p>Dependencies are installed from a so called lock-file. The lock file is generated by PDM to define the absolute truth on which dependency packages to use. There are several commands to manage the lock-file. The most common in the pdm install command. This will determine required dependencies and update the lock-file.</p> <pre><code>C:\\&gt; pdm update\nDEPRECATED: `cross_platform` strategy is deprecated in favor of the new lock targets.\nSee docs: http://pdm-project.org/en/latest/usage/lock-targets/\nC:\\Users\\jonas\\miniconda3\\envs\\calfem-dev-3.12\\Lib\\site-packages\\pdm\\resolver\\providers.py:200: PackageWarning: Skipping\nmatplotlib@3.9.2 because it requires Python&gt;=3.9 but the lock targets to work with Python&gt;=3.8. Instead, another version\nof matplotlib that supports Python&gt;=3.8 will be used.\n...\n\u283c 0:00:04 Resolve for environment (&gt;=3.8) 17 resolved, 0 to resolveINFO: Use `-q/--quiet` to suppress these warnings, or ignore them per-package with `ignore_package_warnings` config in\n[tool.pdm] table.\n  0:00:06 \ud83d\udd12 Lock successful.\nSynchronizing working set with resolved packages: 0 to add, 2 to update, 0 to remove\n\n  \u2714 Update matplotlib 3.7.4 -&gt; 3.7.5 successful\n  \u2714 Update gmsh 4.12.2 -&gt; 4.13.1 successful\n  \u2714 Update calfem-python 3.6.10 -&gt; 3.6.10 successful\n\n  0:00:03 \ud83c\udf89 All complete! 2/2\n\nC:\\&gt; pdm install\nAll packages are synced to date, nothing to do.\n  \u2714 Update calfem-python 3.6.10 -&gt; 3.6.10 successful\n\n  0:00:00 \ud83c\udf89 All complete! 0/0\n</code></pre>"},{"location":"blog/2024/09/09/calfem-for-python-3610-released/#building-the-package","title":"Building the package","text":"<p>To build the package files we use the pdm build command.</p> <pre><code>pdm build\nBuilding sdist...\nBuilt sdist at D:/Users/Jonas/Development/calfem-python/dist\\calfem_python-3.6.10.tar.gz\nBuilding wheel from sdist...\nBuilt wheel at D:/Users/Jonas/Development/calfem-python/dist\\calfem_python-3.6.10-py3-none-any.whl\n</code></pre> <p>This will build a source distribution calfem_python-3.6.10.tar.gz in the dist directory and a prebuilt module or Wheel, calfem_python-3.6.10-py3-none-any.whl, also in the dist directory.</p>"},{"location":"blog/2024/09/09/calfem-for-python-3610-released/#publishing-the-package","title":"Publishing the package","text":"<p>When you have tested your package it is time to publish it in PyPI. This is done with the pdm publish command. This will upload the previously build distribution files.</p>"},{"location":"blog/2024/09/09/calfem-for-python-3610-released/#installing-calfem-for-python","title":"Installing CALFEM for Python","text":"<p>To get the best environment for CALFEM we used the conda-forge Python distribution. First we create a conda environment for CALFEM.</p> <pre><code>(base) C:\\&gt; conda create -n calfem-env-3.12 python=3.12 numpy scipy matplotlib qtpy pyqt tabulate\n</code></pre> <p>This will install optimised versions of numpy and scipy. Next we activate our environment:</p> <pre><code>(base) C:\\&gt; conda activate calfem-env-3.12\n(calfem-env-3.12) C:\\&gt; \n</code></pre> <p>Now we are ready to install the published calfem-python package using pip.</p> <pre><code>(calfem-env-3.12) C:\\&gt; pip install calfem-python\n</code></pre> <p>Now we have a working CALFEM for Python environment for all of our finite element needs.</p>"},{"location":"blog/2024/07/19/thoughts-the-forcepad-application/","title":"Thoughts the ForcePAD application","text":"<p>ForcePAD was developed as part of my PhD thesis almost 20 years ago. The application was developed in C++ using OpenGL for graphics and FLTK for the user interface. At the time, it was state-of-the-art and compiled on all platforms, such as Linux, Windows, and SGI Irix 6.5(!). The application was used extensively in teaching and is still used today.</p> <p>The application has been fixed and updated over the years an is available in the Windows app store. However, it is getting harder and harder to compile on both Windows and MacOS due to OpenGL being deprecated on the Mac and being complicated to maintain on Windows. The application would be ideal for running on an iPad, but as it uses OpenGL 1.1, which is not available on the iPad, this is also a dead end. </p> <p>Reflecting on my recent experience with the partial modernization of the older application, ObjectiveFrame, I see a promising path for the ForcePAD application. While the 3D graphics remain a challenge due to the reliance on a large scene graph library using OpenGL 1.1, the potential for modernization is clear. </p> <p>As the ForcePAD application uses a much simpler 2D graphics model, I have decided it is time for a blank sheet instead of a partial rewrite. This also gives me an opportunity to test some new ideas for the application:</p> <ul> <li>Layers for conceptual sketching, </li> <li>Blending</li> <li>Background speculative computations</li> <li>Immediate-mode user interfaces using ImGUI </li> <li>Upgraded multithreaded computational code using the Eigen C++ library. </li> </ul> <p>I will be publishing my development journey regularly on an upcoming blog. I will leave you with a short video with the user interface in its current state.</p>"},{"location":"blog/2024/08/21/the-conceptual-model-of-forcepad-3/","title":"The conceptual model of ForcePAD 3","text":"<p>When redesigning an application, there is an opportunity to rethink the existing design and make improvements. In the case of ForcePAD 2, it was a simple pixel-based drawing application with a single layer for drawing. Users could add loads and boundary conditions on top of the drawing, and results were displayed on top of the image layer.</p> <p>With ForcePAD 3, I aim to introduce a layered model that allows users to add multiple drawing layers on top of each other, similar to how a designer or architect uses sketch paper. These layers can be hidden and made transparent, providing more flexibility when sketching. In the following sections, I will provide a detailed description of the model and the main classes that implement it.</p>"},{"location":"blog/2024/08/21/the-conceptual-model-of-forcepad-3/#a-multi-layered-approach","title":"A multi layered approach","text":"<p>In ForcePAD 3, I aim to optimize drawing routines by leveraging the GPU more than in ForcePAD 2. To implement the layered model, I have chosen to utilize the render-to-texture capabilities in RayLib. This approach allows for easy implementation of multiple layers. The following code demonstrates the basic idea:</p> <pre><code>RenderTexture2D texture;\n\n...\n\nvoid draw()\n{\n    ...\n\n    BeginTextureMode(texture);\n\n    DrawEllipse(...)\n\n    EndTextureMode()\n\n    DrawTexture(texture, x, y, tint);\n\n    ...\n}\n</code></pre> <p>By rendering to a texture, each layer can be managed independently, providing flexibility and improved performance.</p> <pre><code>RenderTexture2D texture;\n\n...\n\nvoid draw()\n{\n    ...\n\n    BeginTextureMode(texture);\n\n    DrawEllipse(...)\n\n    EndTextureMode()\n\n    DrawTexture(texture, x, y, tint);\n\n    ...\n}\n</code></pre> <p>To abstract this model into something that can implement the layered model in ForcePAD 3, I decided to create a main Drawing class that contains multiple Layer instances, each managing a render texture for a specific layer. The handling of render textures is implemented in the RaylibRenderTexture class.</p> <p>The Drawing class has two methods, beginDraw() and endDraw(), which call the corresponding methods of the Layer class. This simplifies the main drawing routine in the application class:</p> <pre><code>void ForcePadWindow::onDraw()\n{\n    ClearBackground(WHITE);\n\n    m_drawing-&gt;beginDraw();\n\n    // Pixel drawing operations to current layer.\n\n    m_drawing-&gt;endDraw();\n\n    // Draw all textures\n\n    m_drawing-&gt;draw();\n}\n</code></pre> <p>This abstraction allows for easy management of multiple layers and improves the overall organization of the code.</p> <pre><code>void ForcePadWindow::onDraw()\n{\n    ClearBackground(WHITE);\n\n    // Initiate render to current layer and texture\n\n    m_drawing-&gt;beginDraw();\n\n    // Pixel drawing operations to current layer.\n\n    m_drawing-&gt;endDraw();\n\n    m_drawing-&gt;updateMouse(mouseX(), mouseY());\n\n    // Draw all textures\n\n    m_drawing-&gt;draw();\n}\n</code></pre> <p>The Drawing draw() method is also relatively small.</p> <pre><code>void Drawing::draw()\n{\n    ...\n\n    for (auto &amp;layer : m_layers)\n    {\n        if (layer-&gt;visible())\n        {\n            layer-&gt;draw();\n        }\n    }\n\n    ...\n}\n</code></pre> <p>I was initially concerned about the performance impact of using screen-sized render textures. However, after testing it on various hardware, I was pleasantly surprised to find that it performs remarkably well. The application consistently maintains a smooth frame rate of 60 frames per second, even when multiple layers are used.</p>"},{"location":"blog/2024/08/21/the-conceptual-model-of-forcepad-3/#adding-vector-drawing","title":"Adding vector drawing","text":"<p>To improve precision when sketching, I decided to implement vector-based drawing in ForcePAD. RayLib provides many built-in functions for drawing basic shapes, making it a suitable choice as a base for drawing the shapes. To achieve this, I created an abstract class Shape to store generic attributes such as fill color, line color, and border thickness for vector shapes. Additionally, I implemented specific Shape classes like Ellipse, Rectangle, and Line to implement concreate drawing of the shapes.</p> <p>To avoid implementing a separate vector drawing mechanism, each Layer class maintains a set of shapes that are drawn on top of the render texture. As a result, the draw() method of the layer becomes responsible for rendering these shapes.</p> <pre><code>void graphics::Layer::draw()\n{\n    m_renderTexture-&gt;draw(0, 0, m_tint);\n\n    for (auto &amp;shape : m_shapes)\n    {\n        shape-&gt;draw();\n    }\n}\n</code></pre>"},{"location":"blog/2024/08/21/the-conceptual-model-of-forcepad-3/#a-first-verion-of-the-forcepad-model","title":"A first verion of the ForcePAD model","text":"<p>The Drawing class will serve as the foundation for implementing the ForcePAD model. It will be a layered model consisting of the following layers:</p> <ol> <li>Drawing layers: Manages pixel and vector shapes.</li> <li>Result layer: Contains the results from the simulated model.</li> <li>Force and constraints layer: Draws and maintains forces and constraints for the model.</li> </ol> <p>The class will handle interactions with shapes, pixels, forces, and constraints. It will also implement features such as hovering and selection. Additionally, the Drawing class will serve as the main data model for ForcePAD, allowing for serialization of the model to disk. The plan is to use JSON as the primary file format for ForcePAD, enabling easy reading and writing of models by other applications. The implementation of serialization will be done in a separate class.</p> <p>I am satisfied with the current model and it has been successfully implemented in the latest version of ForcePAD 3 on GitHub. No significant modifications have been necessary for the underlying model as of yet.</p>"},{"location":"blog/archive/2025/","title":"2025","text":""},{"location":"blog/archive/2024/","title":"2024","text":""},{"location":"blog/category/opengl/","title":"OpenGL","text":""},{"location":"blog/category/c/","title":"C++","text":""},{"location":"blog/category/ivf/","title":"Ivf++","text":""},{"location":"blog/category/graphics/","title":"Graphics","text":""},{"location":"blog/category/calfem/","title":"CALFEM","text":""},{"location":"blog/category/python/","title":"Python","text":""},{"location":"blog/category/forcepad/","title":"ForcePAD","text":""},{"location":"blog/category/concept/","title":"Concept","text":""},{"location":"blog/category/design/","title":"Design","text":""},{"location":"blog/category/backend/","title":"Backend","text":""},{"location":"blog/category/raylib/","title":"Raylib","text":""},{"location":"blog/category/cmake/","title":"CMake","text":""},{"location":"blog/category/vcpkg/","title":"vcpkg","text":""},{"location":"blog/category/multiplatform/","title":"Multiplatform","text":""}]}