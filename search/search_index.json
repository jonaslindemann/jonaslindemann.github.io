{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Coding thoughts","text":"<p>My name is Jonas Lindemann and I work in HPC where I teach coding in C++, Python and Fortran. I also develop HPC-related software packages (GfxLauncher, ARC Storage Explorer and much more). In my research, I developed several Structural Mechanics applications, primarily for use in conceptual design and teaching. </p> <p></p> <p>This blog is an attempt to open up my development process and thoughts to a wider audience and also encourage input. Recently I have started the process of modernizing several of my older applications and also rewriting them with new concepts and ideas. </p> <p>Welcome!</p> <p>Jonas Lindemann</p>"},{"location":"gen-links/","title":"General","text":"<p>Modern Fortran Book - Online Ingenj\u00f6rens guide till Python Min LU Profil</p>"},{"location":"gh-links/","title":"Projects","text":"<p>ObjectiveFrame Modern Fortran Book - Source Qt Creator Fortran extensions ForcePAD 3 - Development Lightray - 2D rendering library based on Raylib ForcePAD 2.x Ivf++ - Interactive Visualisation Framework - 3D Scenegraph library Ivf2 - Modern reimplementation of Ivf++ OO Fortran examples and lecture GFX Launcher Toolkit CALFEM for Python</p>"},{"location":"yt-links/","title":"Videos","text":"<p>My YouTube channel</p>"},{"location":"yt-links/#courses","title":"Courses","text":""},{"location":"yt-links/#introduction-to-scientific-computing-2024","title":"Introduction to Scientific Computing - 2024","text":""},{"location":"yt-links/#scientific-programming-in-python-and-fortran-2023","title":"Scientific Programming in Python and Fortran - 2023","text":""},{"location":"yt-links/#interactive-software","title":"Interactive Software","text":""},{"location":"yt-links/#lunarc","title":"LUNARC","text":""},{"location":"yt-links/#fortran","title":"Fortran","text":""},{"location":"blog/","title":"Blog","text":""},{"location":"blog/2024/07/19/a-new-backend-for-forcepad/","title":"A new backend for ForcePAD","text":"<p>The current version of ForcePAD is implemented using the FLTK library and OpenGL for graphics. At the time FLTK provided an easy way of implementing an multiplatform application that could run on Windows and Unix/Linux. FLTK provided both an intuitive environment for designing the 2D user interface as well as easy OpenGL context creation. OpenGL context creation on Windows and Unix was implemented very differently on each platform. Having just one way of this enabled ForcePAD to be implemented in a single code base.</p> <p>Using FLTK and OpenGL today has been more problematic. Even though context creation in FLTK is still easy. It is not very flexible preventing new modern OpenGL features from being easily implemented. Also, OpenGL today is a fragmented environment. Apple and macOS are currently not supporting the library and put restrictions on which versions they make available. At this point, I was a bit depressed about the lack of standards in graphics APIs. After I saw a YouTube video on game engines I was impressed with the game library RayLib (https://www.raylib.com/. </p> <p></p> <p>Raylib is a modular game engine that is available on all platforms. When compared to other game engines, Raylib is more of a toolbox where you can use what you need. This is very much the same experience I had with OpenGL a long time ago. The API provides both low-level functions as well as more high-level functions. An example of a very simple RayLib application is shown below:</p> <pre><code>#include \"raylib.h\"\n\nint main() \n{\n    // Initialization\n\n    int screenWidth = 800;\n    int screenHeight = 450;\n\n    InitWindow(screenWidth, screenHeight, \"Simple RayLib Example\");\n\n    SetTargetFPS(60); // Set our game to run at 60 frames-per-second\n\n    // Main game loop\n\n    while (!WindowShouldClose()) \n    {\n        // Draw\n\n        BeginDrawing();\n        ClearBackground(RAYWHITE);\n        DrawText(\"This is RayLib\", 190, 200, 20, LIGHTGRAY);\n        EndDrawing();\n    }\n\n    // De-Initialization\n\n    CloseWindow(); \n\n    return 0;\n}\n</code></pre> <p>This application will compile for any supported platform, which currently are:</p> <ul> <li>Windows</li> <li>Linux</li> <li>macOS</li> <li>iOS</li> <li>Android</li> <li>Raspberry Pi</li> <li>HTML5</li> </ul> <p>This also means that from the same source code, I can build a native application as well as an application that can be run directly on a web page using web assembly.</p> <p>In the following blog posts, I will try to describe how I set up the basic project and implement the basic abstractions for the application.</p> <p>Until the next blog post...</p>"},{"location":"blog/2024/08/14/building-for-many-platforms-is-hard/","title":"Building for many platforms is hard","text":"<p>Choosing the right libraries for your application is just one step in making it run on multiple operating systems. ForcePAD uses CMake to build the application on multiple platforms. CMake is an excellent tool that generates build files for each platform. On Windows it generates Visual Studio solution files. On other platform it generates make files. I started implementing most of the tooling for ForcePAD on Windows thinking that most of this can be easily transferred to macOS. This what not that easy. I will go through the setup in the following sections.</p>"},{"location":"blog/2024/08/14/building-for-many-platforms-is-hard/#windows-and-dependencies","title":"Windows and dependencies","text":"<p>The biggest issue with building applications on Windows is the dependencies that on many other operating systems such as Linux are easily installable using a package manager. Until recently there was no real packages manager available on Windows, requiring you to download, build and install dependencies manually. Today there are several package managers for C++ that can solve this problem, such as Conan and Vcpkg. For ForcePAD I chose to use Vcpkg as it has worked well for other projects. To use Vcpkg you provide a vcpkg.json file in your root build directory. In this file you specify the dependencies you have in your project. An example of this is shown below:</p> <pre><code>{\n    \"name\": \"forcepad\",\n    \"version\": \"0\",\n    \"dependencies\":\n    [\n        {\n            \"name\": \"raylib\",\n            \"platform\": \"windows\"\n        },\n        {\n            \"name\": \"opengl\",\n            \"platform\": \"windows\"\n        },    \n        {\n            \"name\": \"eigen3\",\n            \"platform\": \"windows\"\n        },\n        \"stb\",\n        {\n            \"name\": \"imgui\",\n            \"features\": [\"docking-experimental\"]\n        },\n        {\n            \"name\": \"glfw3\",\n            \"platform\": \"windows\"\n        }\n    ]\n}\n</code></pre> <p>The important stuff is contained in the dependencies section. Here you list the packages you require. The platform attributes indicates for which platform this dependency is required. It is optional, but I will come back to this later. To build the dependencies you type:</p> <pre><code>C:\\...\\&gt;vcpkg install\n</code></pre> <p>This will build the dependencies in your current directory. By default build libraries will be placed in the vcpkg_installed directory. </p> <p>To make sure these libraries are found by CMake we need to define a CMakePresets.json file where we specify where Vcpkg can be found for the different platforms. The preset file for ForcePAD is shown below:</p> <pre><code>{\n  \"version\": 3,\n  \"configurePresets\": [\n    {\n      \"name\": \"default\",\n      \"toolchainFile\": \"e:/vcpkg/scripts/buildsystems/vcpkg.cmake\"\n    },\n    {\n      \"name\": \"linux\",\n      \"toolchainFile\": \"/home/bmjl/vcpkg/scripts/buildsystems/vcpkg.cmake\"\n    },\n    {\n      \"name\": \"macos\",\n      \"toolchainFile\": \"/Users/lindemann/vcpkg/scripts/buildsystems/vcpkg.cmake\"\n    }\n  ]\n}\n</code></pre>"},{"location":"blog/2024/08/14/building-for-many-platforms-is-hard/#a-cmakeliststxt-file-for-all-platforms","title":"A CMakeLists.txt file for all platforms","text":"<p>The nice thing using a package manager is that the actual CMakeLists.txt file doesn't have to have explicit paths for different libraries. Normal find_package(...) commands can be called and corresponding paths will be found. The commands used to find the packages are the following:</p> <pre><code>find_package(raylib CONFIG REQUIRED)\nfind_package(Eigen3 CONFIG REQUIRED)\nfind_package(imgui CONFIG REQUIRED)\nfind_package(OpenGL REQUIRED)\nfind_package(Stb REQUIRED) \nfind_package(glfw3 CONFIG REQUIRED)\n</code></pre>"},{"location":"blog/2024/08/14/building-for-many-platforms-is-hard/#configuring-and-building-with-cmake","title":"Configuring and building with CMake","text":"<p>To configure a debug build of ForcePAD using the default preset CMake is called with the following command line:</p> <pre><code>C:\\...\\&gt;cmake -B build-debug -DCMAKE_BUILD_TYPE=Debug --preset default\n</code></pre> <p>This configures the ForcePAD debug build in the build-debug directory. Building ForcePAD can now be done using the following command:</p> <pre><code>C:\\...\\&gt;cmake --build build-debug --config Debug -- /m\n</code></pre> <p>It is of course possible to use Visual Studio solution files contained in the build-debug directory to edit and build ForcePAD.</p>"},{"location":"blog/2024/08/14/building-for-many-platforms-is-hard/#multiplatform-is-still-hard","title":"Multiplatform is still hard","text":"<p>At this point I was very happy to have build system that at least in theory should work on both Windows and macOS. I copied over all my source files to my newly aquired Mac mini. Installed all development tools and MacBrew. </p> <p>I ran the same commands and Vcpkg started to build the dependencies, but the compiler and linker errors where plenty. I realised that using the Apple provided g++ compiler was not a good choice, so I switched to the brew provided compilers g++-13/gcc-13. This required me to make sure that they where used instead of the Apple-compilers. Using the following statements I set the required environment variables so that CMake and Vcpkg picked up the right compilers:</p> <pre><code>export CXX=g++-13\nexport CC=gcc-13\n</code></pre> <p>This reduced some of the compiler errors, but I still got a lot of linker errors with Vcpkg build libraries. Then I had an idea. Perhaps I should use brew to provide some of the packages instead. I added the platform directive in the vcpkg.json file and I told vcpkg only to build raylib, opengl, eigen3 and glfw3 on Windows. This make a lot of errors go away. However I got stuck on missing system libraries from Apple such as CoreGraphics and Cocoa. I modified my CMakeLists.txt for the main ForcePAD executable to the following:</p> <pre><code>if (CMAKE_BUILD_TYPE STREQUAL \"Debug\")\n    if (APPLE)\n        add_executable(forcepad3d main.cpp forcepad_window.cpp forcepad_window.h)\n        target_include_directories(forcepad3d PRIVATE ${gui_INCLUDE_DIRS} ${raylib_INCLUDE_DIRS})\n        target_link_libraries(forcepad3d PRIVATE \"-framework CoreGraphics\" \"-framework Cocoa\" \"-framework IOKit\" \"-framework OpenGL\" \"-framework CoreFoundation\" rlimguid guid graphicsd ${raylib_LIBRARIES} OpenGL::GL imgui::imgui glfw)\n    else()\n        ...\n</code></pre> <p>These changes made ForcePAD build on macOS and worked on first startup. To make configuration a bit I created a build.cmd on Windows and a build.sh on macOS to automate some of the steps.</p>"},{"location":"blog/2024/08/14/building-for-many-platforms-is-hard/#conclusions","title":"Conclusions","text":"<p>Building a multiplatform application is hard. Raylib made it a bit easier on the source level, but still requires dependencies on the system side. It also worries me a bit that Raylib relies on OpenGL, which is kind of unsupported on macOS, but I suspect the Raylib developers could do some port of the rlgl to metal or other libraries.</p>"},{"location":"blog/2024/07/19/thoughts-the-forcepad-application/","title":"Thoughts the ForcePAD application","text":"<p>ForcePAD was developed as part of my PhD thesis almost 20 years ago. The application was developed in C++ using OpenGL for graphics and FLTK for the user interface. At the time, it was state-of-the-art and compiled on all platforms, such as Linux, Windows, and SGI Irix 6.5(!). The application was used extensively in teaching and is still used today.</p> <p>The application has been fixed and updated over the years an is available in the Windows app store. However, it is getting harder and harder to compile on both Windows and MacOS due to OpenGL being deprecated on the Mac and being complicated to maintain on Windows. The application would be ideal for running on an iPad, but as it uses OpenGL 1.1, which is not available on the iPad, this is also a dead end. </p> <p>Reflecting on my recent experience with the partial modernization of the older application, ObjectiveFrame, I see a promising path for the ForcePAD application. While the 3D graphics remain a challenge due to the reliance on a large scene graph library using OpenGL 1.1, the potential for modernization is clear. </p> <p>As the ForcePAD application uses a much simpler 2D graphics model, I have decided it is time for a blank sheet instead of a partial rewrite. This also gives me an opportunity to test some new ideas for the application:</p> <ul> <li>Layers for conceptual sketching, </li> <li>Blending</li> <li>Background speculative computations</li> <li>Immediate-mode user interfaces using ImGUI </li> <li>Upgraded multithreaded computational code using the Eigen C++ library. </li> </ul> <p>I will be publishing my development journey regularly on an upcoming blog. I will leave you with a short video with the user interface in its current state.</p>"},{"location":"blog/2024/08/21/the-conceptual-model-of-forcepad-3/","title":"The conceptual model of ForcePAD 3","text":"<p>When redesigning an application, there is an opportunity to rethink the existing design and make improvements. In the case of ForcePAD 2, it was a simple pixel-based drawing application with a single layer for drawing. Users could add loads and boundary conditions on top of the drawing, and results were displayed on top of the image layer.</p> <p>With ForcePAD 3, I aim to introduce a layered model that allows users to add multiple drawing layers on top of each other, similar to how a designer or architect uses sketch paper. These layers can be hidden and made transparent, providing more flexibility when sketching. In the following sections, I will provide a detailed description of the model and the main classes that implement it.</p>"},{"location":"blog/2024/08/21/the-conceptual-model-of-forcepad-3/#a-multi-layered-approach","title":"A multi layered approach","text":"<p>In ForcePAD 3, I aim to optimize drawing routines by leveraging the GPU more than in ForcePAD 2. To implement the layered model, I have chosen to utilize the render-to-texture capabilities in RayLib. This approach allows for easy implementation of multiple layers. The following code demonstrates the basic idea:</p> <pre><code>RenderTexture2D texture;\n\n...\n\nvoid draw()\n{\n    ...\n\n    BeginTextureMode(texture);\n\n    DrawEllipse(...)\n\n    EndTextureMode()\n\n    DrawTexture(texture, x, y, tint);\n\n    ...\n}\n</code></pre> <p>By rendering to a texture, each layer can be managed independently, providing flexibility and improved performance.</p> <pre><code>RenderTexture2D texture;\n\n...\n\nvoid draw()\n{\n    ...\n\n    BeginTextureMode(texture);\n\n    DrawEllipse(...)\n\n    EndTextureMode()\n\n    DrawTexture(texture, x, y, tint);\n\n    ...\n}\n</code></pre> <p>To abstract this model into something that can implement the layered model in ForcePAD 3, I decided to create a main Drawing class that contains multiple Layer instances, each managing a render texture for a specific layer. The handling of render textures is implemented in the RaylibRenderTexture class.</p> <p>The Drawing class has two methods, beginDraw() and endDraw(), which call the corresponding methods of the Layer class. This simplifies the main drawing routine in the application class:</p> <pre><code>void ForcePadWindow::onDraw()\n{\n    ClearBackground(WHITE);\n\n    m_drawing-&gt;beginDraw();\n\n    // Pixel drawing operations to current layer.\n\n    m_drawing-&gt;endDraw();\n\n    // Draw all textures\n\n    m_drawing-&gt;draw();\n}\n</code></pre> <p>This abstraction allows for easy management of multiple layers and improves the overall organization of the code.</p> <pre><code>void ForcePadWindow::onDraw()\n{\n    ClearBackground(WHITE);\n\n    // Initiate render to current layer and texture\n\n    m_drawing-&gt;beginDraw();\n\n    // Pixel drawing operations to current layer.\n\n    m_drawing-&gt;endDraw();\n\n    m_drawing-&gt;updateMouse(mouseX(), mouseY());\n\n    // Draw all textures\n\n    m_drawing-&gt;draw();\n}\n</code></pre> <p>The Drawing draw() method is also relatively small.</p> <pre><code>void Drawing::draw()\n{\n    ...\n\n    for (auto &amp;layer : m_layers)\n    {\n        if (layer-&gt;visible())\n        {\n            layer-&gt;draw();\n        }\n    }\n\n    ...\n}\n</code></pre> <p>I was initially concerned about the performance impact of using screen-sized render textures. However, after testing it on various hardware, I was pleasantly surprised to find that it performs remarkably well. The application consistently maintains a smooth frame rate of 60 frames per second, even when multiple layers are used.</p>"},{"location":"blog/2024/08/21/the-conceptual-model-of-forcepad-3/#adding-vector-drawing","title":"Adding vector drawing","text":"<p>To improve precision when sketching, I decided to implement vector-based drawing in ForcePAD. RayLib provides many built-in functions for drawing basic shapes, making it a suitable choice as a base for drawing the shapes. To achieve this, I created an abstract class Shape to store generic attributes such as fill color, line color, and border thickness for vector shapes. Additionally, I implemented specific Shape classes like Ellipse, Rectangle, and Line to implement concreate drawing of the shapes.</p> <p>To avoid implementing a separate vector drawing mechanism, each Layer class maintains a set of shapes that are drawn on top of the render texture. As a result, the draw() method of the layer becomes responsible for rendering these shapes.</p> <pre><code>void graphics::Layer::draw()\n{\n    m_renderTexture-&gt;draw(0, 0, m_tint);\n\n    for (auto &amp;shape : m_shapes)\n    {\n        shape-&gt;draw();\n    }\n}\n</code></pre>"},{"location":"blog/2024/08/21/the-conceptual-model-of-forcepad-3/#a-first-verion-of-the-forcepad-model","title":"A first verion of the ForcePAD model","text":"<p>The Drawing class will serve as the foundation for implementing the ForcePAD model. It will be a layered model consisting of the following layers:</p> <ol> <li>Drawing layers: Manages pixel and vector shapes.</li> <li>Result layer: Contains the results from the simulated model.</li> <li>Force and constraints layer: Draws and maintains forces and constraints for the model.</li> </ol> <p>The class will handle interactions with shapes, pixels, forces, and constraints. It will also implement features such as hovering and selection. Additionally, the Drawing class will serve as the main data model for ForcePAD, allowing for serialization of the model to disk. The plan is to use JSON as the primary file format for ForcePAD, enabling easy reading and writing of models by other applications. The implementation of serialization will be done in a separate class.</p> <p>I am satisfied with the current model and it has been successfully implemented in the latest version of ForcePAD 3 on GitHub. No significant modifications have been necessary for the underlying model as of yet.</p>"},{"location":"blog/archive/2024/","title":"2024","text":""},{"location":"blog/category/forcepad/","title":"ForcePAD","text":""},{"location":"blog/category/c/","title":"C++","text":""},{"location":"blog/category/concept/","title":"Concept","text":""},{"location":"blog/category/design/","title":"Design","text":""},{"location":"blog/category/backend/","title":"Backend","text":""},{"location":"blog/category/raylib/","title":"Raylib","text":""},{"location":"blog/category/cmake/","title":"CMake","text":""},{"location":"blog/category/vcpkg/","title":"vcpkg","text":""},{"location":"blog/category/multiplatform/","title":"Multiplatform","text":""}]}