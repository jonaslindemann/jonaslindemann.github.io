{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Coding thoughts","text":"<p>My name is Jonas Lindemann and I work in HPC where I teach coding in C++, Python and Fortran. I also develop HPC-related software packages (GfxLauncher, ARC Storage Explorer and much more). In my research, I developed several Structural Mechanics applications, primarily for use in conceptual design and teaching. </p> <p></p> <p>This blog is an attempt to open up my development process and thoughts to a wider audience and also encourage input. Recently I have started the process of modernizing several of my older applications and also rewriting them with new concepts and ideas. </p> <p>Welcome!</p> <p>Jonas Lindemann</p>"},{"location":"gen-links/","title":"General","text":"<p>Modern Fortran Book - Online Ingenj\u00f6rens guide till Python Min LU Profil</p>"},{"location":"gh-links/","title":"Projects","text":"<p>ObjectiveFrame Modern Fortran Book - Source Qt Creator Fortran extensions ForcePAD 3 - Development Lightray - 2D rendering library based on Raylib ForcePAD 2.x Ivf++ - Interactive Visualisation Framework - 3D Scenegraph library Ivf2 - Modern reimplementation of Ivf++ OO Fortran examples and lecture GFX Launcher Toolkit CALFEM for Python</p>"},{"location":"yt-links/","title":"Videos","text":"<p>My YouTube channel</p>"},{"location":"yt-links/#courses","title":"Courses","text":""},{"location":"yt-links/#introduction-to-scientific-computing-2024","title":"Introduction to Scientific Computing - 2024","text":""},{"location":"yt-links/#scientific-programming-in-python-and-fortran-2023","title":"Scientific Programming in Python and Fortran - 2023","text":""},{"location":"yt-links/#interactive-software","title":"Interactive Software","text":""},{"location":"yt-links/#lunarc","title":"LUNARC","text":""},{"location":"yt-links/#fortran","title":"Fortran","text":""},{"location":"blog/","title":"Blog","text":""},{"location":"blog/2024/07/19/a-new-backend-for-forcepad/","title":"A new backend for ForcePAD","text":"<p>The current version of ForcePAD is implemented using the FLTK library and OpenGL for graphics. At the time FLTK provided an easy way of implementing an multiplatform application that could run on Windows and Unix/Linux. FLTK provided both an intuitive environment for designing the 2D user interface as well as easy OpenGL context creation. OpenGL context creation on Windows and Unix was implemented very differently on each platform. Having just one way of this enabled ForcePAD to be implemented in a single code base.</p> <p>Using FLTK and OpenGL today has been more problematic. Even though context creation in FLTK is still easy. It is not very flexible preventing new modern OpenGL features from being easily implemented. Also, OpenGL today is a fragmented environment. Apple and macOS are currently not supporting the library and put restrictions on which versions they make available. At this point, I was a bit depressed about the lack of standards in graphics APIs. After I saw a YouTube video on game engines I was impressed with the game library RayLib (https://www.raylib.com/. </p> <p></p> <p>Raylib is a modular game engine that is available on all platforms. When compared to other game engines, Raylib is more of a toolbox where you can use what you need. This is very much the same experience I had with OpenGL a long time ago. The API provides both low-level functions as well as more high-level functions. An example of a very simple RayLib application is shown below:</p> <pre><code>#include \"raylib.h\"\n\nint main() \n{\n    // Initialization\n\n    int screenWidth = 800;\n    int screenHeight = 450;\n\n    InitWindow(screenWidth, screenHeight, \"Simple RayLib Example\");\n\n    SetTargetFPS(60); // Set our game to run at 60 frames-per-second\n\n    // Main game loop\n\n    while (!WindowShouldClose()) \n    {\n        // Draw\n\n        BeginDrawing();\n        ClearBackground(RAYWHITE);\n        DrawText(\"This is RayLib\", 190, 200, 20, LIGHTGRAY);\n        EndDrawing();\n    }\n\n    // De-Initialization\n\n    CloseWindow(); \n\n    return 0;\n}\n</code></pre> <p>This application will compile for any supported platform, which currently are:</p> <ul> <li>Windows</li> <li>Linux</li> <li>macOS</li> <li>iOS</li> <li>Android</li> <li>Raspberry Pi</li> <li>HTML5</li> </ul> <p>This also means that from the same source code, I can build a native application as well as an application that can be run directly on a web page using web assembly.</p> <p>In the following blog posts, I will try to describe how I set up the basic project and implement the basic abstractions for the application.</p> <p>Until the next blog post...</p>"},{"location":"blog/2024/08/14/building-for-many-platforms-is-hard/","title":"Building for many platforms is hard","text":"<p>Choosing the right libraries for your application is just one step in making it run on multiple operating systems. ForcePAD uses CMake to build the application on multiple platforms. CMake is an excellent tool that generates build files for each platform. On Windows it generates Visual Studio solution files. On other platform it generates make files. I started implementing most of the tooling for ForcePAD on Windows thinking that most of this can be easily transferred to macOS. This what not that easy. I will go through the setup in the following sections.</p>"},{"location":"blog/2024/08/14/building-for-many-platforms-is-hard/#windows-and-dependencies","title":"Windows and dependencies","text":"<p>The biggest issue with building applications on Windows is the dependencies that on many other operating systems such as Linux are easily installable using a package manager. Until recently there was no real packages manager available on Windows, requiring you to download, build and install dependencies manually. Today there are several package managers for C++ that can solve this problem, such as Conan and Vcpkg. For ForcePAD I chose to use Vcpkg as it has worked well for other projects. To use Vcpkg you provide a vcpkg.json file in your root build directory. In this file you specify the dependencies you have in your project. An example of this is shown below:</p> <pre><code>{\n    \"name\": \"forcepad\",\n    \"version\": \"0\",\n    \"dependencies\":\n    [\n        {\n            \"name\": \"raylib\",\n            \"platform\": \"windows\"\n        },\n        {\n            \"name\": \"opengl\",\n            \"platform\": \"windows\"\n        },    \n        {\n            \"name\": \"eigen3\",\n            \"platform\": \"windows\"\n        },\n        \"stb\",\n        {\n            \"name\": \"imgui\",\n            \"features\": [\"docking-experimental\"]\n        },\n        {\n            \"name\": \"glfw3\",\n            \"platform\": \"windows\"\n        }\n    ]\n}\n</code></pre> <p>The important stuff is contained in the dependencies section. Here you list the packages you require. The platform attributes indicates for which platform this dependency is required. It is optional, but I will come back to this later. To build the dependencies you type:</p> <pre><code>C:\\...\\&gt;vcpkg install\n</code></pre> <p>This will build the dependencies in your current directory. By default build libraries will be placed in the vcpkg_installed directory. </p> <p>To make sure these libraries are found by CMake we need to define a CMakePresets.json file where we specify where Vcpkg can be found for the different platforms. The preset file for ForcePAD is shown below:</p> <pre><code>{\n  \"version\": 3,\n  \"configurePresets\": [\n    {\n      \"name\": \"default\",\n      \"toolchainFile\": \"e:/vcpkg/scripts/buildsystems/vcpkg.cmake\"\n    },\n    {\n      \"name\": \"linux\",\n      \"toolchainFile\": \"/home/bmjl/vcpkg/scripts/buildsystems/vcpkg.cmake\"\n    },\n    {\n      \"name\": \"macos\",\n      \"toolchainFile\": \"/Users/lindemann/vcpkg/scripts/buildsystems/vcpkg.cmake\"\n    }\n  ]\n}\n</code></pre>"},{"location":"blog/2024/08/14/building-for-many-platforms-is-hard/#a-cmakeliststxt-file-for-all-platforms","title":"A CMakeLists.txt file for all platforms","text":"<p>The nice thing using a package manager is that the actual CMakeLists.txt file doesn't have to have explicit paths for different libraries. Normal find_package(...) commands can be called and corresponding paths will be found. The commands used to find the packages are the following:</p> <pre><code>find_package(raylib CONFIG REQUIRED)\nfind_package(Eigen3 CONFIG REQUIRED)\nfind_package(imgui CONFIG REQUIRED)\nfind_package(OpenGL REQUIRED)\nfind_package(Stb REQUIRED) \nfind_package(glfw3 CONFIG REQUIRED)\n</code></pre>"},{"location":"blog/2024/08/14/building-for-many-platforms-is-hard/#configuring-and-building-with-cmake","title":"Configuring and building with CMake","text":"<p>To configure a debug build of ForcePAD using the default preset CMake is called with the following command line:</p> <pre><code>C:\\...\\&gt;cmake -B build-debug -DCMAKE_BUILD_TYPE=Debug --preset default\n</code></pre> <p>This configures the ForcePAD debug build in the build-debug directory. Building ForcePAD can now be done using the following command:</p> <pre><code>C:\\...\\&gt;cmake --build build-debug --config Debug -- /m\n</code></pre> <p>It is of course possible to use Visual Studio solution files contained in the build-debug directory to edit and build ForcePAD.</p>"},{"location":"blog/2024/08/14/building-for-many-platforms-is-hard/#multiplatform-is-still-hard","title":"Multiplatform is still hard","text":"<p>At this point I was very happy to have build system that at least in theory should work on both Windows and macOS. I copied over all my source files to my newly aquired Mac mini. Installed all development tools and MacBrew. </p> <p>I ran the same commands and Vcpkg started to build the dependencies, but the compiler and linker errors where plenty. I realised that using the Apple provided g++ compiler was not a good choice, so I switched to the brew provided compilers g++-13/gcc-13. This required me to make sure that they where used instead of the Apple-compilers. Using the following statements I set the required environment variables so that CMake and Vcpkg picked up the right compilers:</p> <pre><code>export CXX=g++-13\nexport CC=gcc-13\n</code></pre> <p>This reduced some of the compiler errors, but I still got a lot of linker errors with Vcpkg build libraries. Then I had an idea. Perhaps I should use brew to provide some of the packages instead. I added the platform directive in the vcpkg.json file and I told vcpkg only to build raylib, opengl, eigen3 and glfw3 on Windows. This make a lot of errors go away. However I got stuck on missing system libraries from Apple such as CoreGraphics and Cocoa. I modified my CMakeLists.txt for the main ForcePAD executable to the following:</p> <pre><code>if (CMAKE_BUILD_TYPE STREQUAL \"Debug\")\n    if (APPLE)\n        add_executable(forcepad3d main.cpp forcepad_window.cpp forcepad_window.h)\n        target_include_directories(forcepad3d PRIVATE ${gui_INCLUDE_DIRS} ${raylib_INCLUDE_DIRS})\n        target_link_libraries(forcepad3d PRIVATE \"-framework CoreGraphics\" \"-framework Cocoa\" \"-framework IOKit\" \"-framework OpenGL\" \"-framework CoreFoundation\" rlimguid guid graphicsd ${raylib_LIBRARIES} OpenGL::GL imgui::imgui glfw)\n    else()\n        ...\n</code></pre> <p>These changes made ForcePAD build on macOS and worked on first startup. To make configuration a bit I created a build.cmd on Windows and a build.sh on macOS to automate some of the steps.</p>"},{"location":"blog/2024/08/14/building-for-many-platforms-is-hard/#conclusions","title":"Conclusions","text":"<p>Building a multiplatform application is hard. Raylib made it a bit easier on the source level, but still requires dependencies on the system side. It also worries me a bit that Raylib relies on OpenGL, which is kind of unsupported on macOS, but I suspect the Raylib developers could do some port of the rlgl to metal or other libraries.</p>"},{"location":"blog/2024/09/09/calfem-for-python-3610-released/","title":"CALFEM for Python 3.6.10 released","text":"<p>CALFEM for Python is a comprehensive package designed for learning the finite element method. Originally developed in the 1980s using Fortran, CALFEM has since evolved to support MATLAB and Python. The Python version was specifically created to facilitate the course \"Software Development for Technical Applications\" at Structural Mechanics in Lund. Throughout the course, students gain hands-on experience in developing a complete finite element application in Python. They learn how to implement various components, including mesh generation, solver, user interface, and visualization routines.</p> <p>In this blog post, I will provide a detailed explanation of the packaging and installation process for CALFEM.</p>"},{"location":"blog/2024/09/09/calfem-for-python-3610-released/#distributing-and-packaging-calfem-for-python","title":"Distributing and packaging CALFEM for Python","text":"<p>The early versions of CALFEM for Python were distributed by placing all the Python source code files in a zip-archive and linking it on Structural Mechanics web pages. However, this approach proved to be cumbersome. In 2009, we transitioned to using Subversion as a source repository for better development tracking. In recent years, we have migrated all our development efforts to GitHub.</p> <p>Using a source repository allowed us to tag released versions and provide links to the latest version of CALFEM on our web pages. However, even with this improvement, the process of installing the package and setting the PYTHONPATH still required manual installation of all the dependencies. To address this issue, I modified the repository to create a package called calfem-python using setuptools in Python. This involved creating a special setup.py script in the source directory, which is used to generate the packages. The generated tar files are then uploaded to PyPI using specific commands.</p>"},{"location":"blog/2024/09/09/calfem-for-python-3610-released/#creating-packages-with-pdm","title":"Creating packages with PDM","text":"<p>Releasing packages in the traditional way can be unnecessarily complicated. Fortunately, there are several packaging tools available that simplify the package creation process. One such tool is PDM (Python Package and Dependency Manager), which I recently discovered and found to be incredibly user-friendly.</p> <p>To utilize PDM, you'll need to make some modifications to your source tree. In the case of the calfem-python package, all source modules were initially located in the calfem directory within the source tree. However, PDM requires all source files to be placed under the src directory, as demonstrated below.</p> <pre><code>\u251c\u2500\u2500\u2500src\n\u2502   \u2514\u2500\u2500\u2500calfem\n</code></pre> <p>To use PDM in your source tree you run pdm init the first time. This will ask you a number of questions and generate a pyproject.toml file. The pyproject.toml file of the calfem-python is shown below:</p> <p>First we define the main project attributes such as package-name and version.</p> <pre><code>[project]\nname = \"calfem-python\"\nversion = \"3.6.10\"\ndescription = \"CALFEM for Python\"\nauthors = [\n    {name = \"Jonas Lindemann\", email = \"jonas.lindemann@lunarc.lu.se\"},\n    {name = \"Jonas Lindemann\", email = \"jonas.lindemann@gmail.com\"},\n]\n</code></pre> <p>Next we need to specify the hard dependencies of the package:</p> <pre><code>dependencies = [\n    \"gmsh\",\n    \"matplotlib\",\n    \"numpy\",\n    \"scipy\",\n    \"tabulate\",\n]\n\nrequires-python = \"&gt;=3.8\"\n</code></pre> <p>In the following part we specify some package metadata such as README files, license type and keywords.</p> <pre><code>readme = \"README.md\"\nlicense = {text = \"MIT\"}\nkeywords = [\n    \"finite element\",\n    \"math\",\n    \"numerics\",\n]\n</code></pre> <p>In the classifiers section we give some additional project metadata.</p> <pre><code>classifiers = [\n    \"Development Status :: 4 - Beta\",\n    \"Intended Audience :: Developers\",\n    \"License :: OSI Approved :: MIT License\",\n    \"Programming Language :: Python :: 3\",\n    \"Programming Language :: Python :: 3.10\",\n    \"Programming Language :: Python :: 3.11\",\n    \"Programming Language :: Python :: 3.12\",\n    \"Programming Language :: Python :: 3.7\",\n    \"Programming Language :: Python :: 3.8\",\n    \"Programming Language :: Python :: 3.9\",\n    \"Topic :: Software Development :: Build Tools\",\n]\n</code></pre> <p>We can also provide a linke to a project home page.</p> <pre><code>[project.urls]\nHomepage = \"https://github.com/CALFEM/calfem-python\"\n</code></pre> <p>The pyproject.toml file is a standardised build file used by many build systems. To specify that this package requires PDM we specify this in the build-system secion.</p> <pre><code>[build-system]\nrequires = [\"pdm-backend\"]\nbuild-backend = \"pdm.backend\"\n\n[tool.pdm]\ndistribution = true\n</code></pre> <p>Finally we list any optional dependencies.</p> <pre><code>[project.optional-dependencies]\nvisvis = [ \"visvis\" ]\nvedo = [ \"vedo\" ]\npyvtk = [ \"pyvtk\" ]\nqtpy = [ \"qtpy\" ]\n</code></pre>"},{"location":"blog/2024/09/09/calfem-for-python-3610-released/#creating-the-package","title":"Creating the package","text":"<p>Dependencies are installed from a so called lock-file. The lock file is generated by PDM to define the absolute truth on which dependency packages to use. There are several commands to manage the lock-file. The most common in the pdm install command. This will determine required dependencies and update the lock-file.</p> <pre><code>C:\\&gt; pdm update\nDEPRECATED: `cross_platform` strategy is deprecated in favor of the new lock targets.\nSee docs: http://pdm-project.org/en/latest/usage/lock-targets/\nC:\\Users\\jonas\\miniconda3\\envs\\calfem-dev-3.12\\Lib\\site-packages\\pdm\\resolver\\providers.py:200: PackageWarning: Skipping\nmatplotlib@3.9.2 because it requires Python&gt;=3.9 but the lock targets to work with Python&gt;=3.8. Instead, another version\nof matplotlib that supports Python&gt;=3.8 will be used.\n...\n\u283c 0:00:04 Resolve for environment (&gt;=3.8) 17 resolved, 0 to resolveINFO: Use `-q/--quiet` to suppress these warnings, or ignore them per-package with `ignore_package_warnings` config in\n[tool.pdm] table.\n  0:00:06 \ud83d\udd12 Lock successful.\nSynchronizing working set with resolved packages: 0 to add, 2 to update, 0 to remove\n\n  \u2714 Update matplotlib 3.7.4 -&gt; 3.7.5 successful\n  \u2714 Update gmsh 4.12.2 -&gt; 4.13.1 successful\n  \u2714 Update calfem-python 3.6.10 -&gt; 3.6.10 successful\n\n  0:00:03 \ud83c\udf89 All complete! 2/2\n\nC:\\&gt; pdm install\nAll packages are synced to date, nothing to do.\n  \u2714 Update calfem-python 3.6.10 -&gt; 3.6.10 successful\n\n  0:00:00 \ud83c\udf89 All complete! 0/0\n</code></pre>"},{"location":"blog/2024/09/09/calfem-for-python-3610-released/#building-the-package","title":"Building the package","text":"<p>To build the package files we use the pdm build command.</p> <pre><code>pdm build\nBuilding sdist...\nBuilt sdist at D:/Users/Jonas/Development/calfem-python/dist\\calfem_python-3.6.10.tar.gz\nBuilding wheel from sdist...\nBuilt wheel at D:/Users/Jonas/Development/calfem-python/dist\\calfem_python-3.6.10-py3-none-any.whl\n</code></pre> <p>This will build a source distribution calfem_python-3.6.10.tar.gz in the dist directory and a prebuilt module or Wheel, calfem_python-3.6.10-py3-none-any.whl, also in the dist directory.</p>"},{"location":"blog/2024/09/09/calfem-for-python-3610-released/#publishing-the-package","title":"Publishing the package","text":"<p>When you have tested your package it is time to publish it in PyPI. This is done with the pdm publish command. This will upload the previously build distribution files.</p>"},{"location":"blog/2024/09/09/calfem-for-python-3610-released/#installing-calfem-for-python","title":"Installing CALFEM for Python","text":"<p>To get the best environment for CALFEM we used the conda-forge Python distribution. First we create a conda environment for CALFEM.</p> <pre><code>(base) C:\\&gt; conda create -n calfem-env-3.12 python=3.12 numpy scipy matplotlib qtpy pyqt tabulate\n</code></pre> <p>This will install optimised versions of numpy and scipy. Next we activate our environment:</p> <pre><code>(base) C:\\&gt; conda activate calfem-env-3.12\n(calfem-env-3.12) C:\\&gt; \n</code></pre> <p>Now we are ready to install the published calfem-python package using pip.</p> <pre><code>(calfem-env-3.12) C:\\&gt; pip install calfem-python\n</code></pre> <p>Now we have a working CALFEM for Python environment for all of our finite element needs.</p>"},{"location":"blog/2024/07/19/thoughts-the-forcepad-application/","title":"Thoughts the ForcePAD application","text":"<p>ForcePAD was developed as part of my PhD thesis almost 20 years ago. The application was developed in C++ using OpenGL for graphics and FLTK for the user interface. At the time, it was state-of-the-art and compiled on all platforms, such as Linux, Windows, and SGI Irix 6.5(!). The application was used extensively in teaching and is still used today.</p> <p>The application has been fixed and updated over the years an is available in the Windows app store. However, it is getting harder and harder to compile on both Windows and MacOS due to OpenGL being deprecated on the Mac and being complicated to maintain on Windows. The application would be ideal for running on an iPad, but as it uses OpenGL 1.1, which is not available on the iPad, this is also a dead end. </p> <p>Reflecting on my recent experience with the partial modernization of the older application, ObjectiveFrame, I see a promising path for the ForcePAD application. While the 3D graphics remain a challenge due to the reliance on a large scene graph library using OpenGL 1.1, the potential for modernization is clear. </p> <p>As the ForcePAD application uses a much simpler 2D graphics model, I have decided it is time for a blank sheet instead of a partial rewrite. This also gives me an opportunity to test some new ideas for the application:</p> <ul> <li>Layers for conceptual sketching, </li> <li>Blending</li> <li>Background speculative computations</li> <li>Immediate-mode user interfaces using ImGUI </li> <li>Upgraded multithreaded computational code using the Eigen C++ library. </li> </ul> <p>I will be publishing my development journey regularly on an upcoming blog. I will leave you with a short video with the user interface in its current state.</p>"},{"location":"blog/2024/08/21/the-conceptual-model-of-forcepad-3/","title":"The conceptual model of ForcePAD 3","text":"<p>When redesigning an application, there is an opportunity to rethink the existing design and make improvements. In the case of ForcePAD 2, it was a simple pixel-based drawing application with a single layer for drawing. Users could add loads and boundary conditions on top of the drawing, and results were displayed on top of the image layer.</p> <p>With ForcePAD 3, I aim to introduce a layered model that allows users to add multiple drawing layers on top of each other, similar to how a designer or architect uses sketch paper. These layers can be hidden and made transparent, providing more flexibility when sketching. In the following sections, I will provide a detailed description of the model and the main classes that implement it.</p>"},{"location":"blog/2024/08/21/the-conceptual-model-of-forcepad-3/#a-multi-layered-approach","title":"A multi layered approach","text":"<p>In ForcePAD 3, I aim to optimize drawing routines by leveraging the GPU more than in ForcePAD 2. To implement the layered model, I have chosen to utilize the render-to-texture capabilities in RayLib. This approach allows for easy implementation of multiple layers. The following code demonstrates the basic idea:</p> <pre><code>RenderTexture2D texture;\n\n...\n\nvoid draw()\n{\n    ...\n\n    BeginTextureMode(texture);\n\n    DrawEllipse(...)\n\n    EndTextureMode()\n\n    DrawTexture(texture, x, y, tint);\n\n    ...\n}\n</code></pre> <p>By rendering to a texture, each layer can be managed independently, providing flexibility and improved performance.</p> <pre><code>RenderTexture2D texture;\n\n...\n\nvoid draw()\n{\n    ...\n\n    BeginTextureMode(texture);\n\n    DrawEllipse(...)\n\n    EndTextureMode()\n\n    DrawTexture(texture, x, y, tint);\n\n    ...\n}\n</code></pre> <p>To abstract this model into something that can implement the layered model in ForcePAD 3, I decided to create a main Drawing class that contains multiple Layer instances, each managing a render texture for a specific layer. The handling of render textures is implemented in the RaylibRenderTexture class.</p> <p>The Drawing class has two methods, beginDraw() and endDraw(), which call the corresponding methods of the Layer class. This simplifies the main drawing routine in the application class:</p> <pre><code>void ForcePadWindow::onDraw()\n{\n    ClearBackground(WHITE);\n\n    m_drawing-&gt;beginDraw();\n\n    // Pixel drawing operations to current layer.\n\n    m_drawing-&gt;endDraw();\n\n    // Draw all textures\n\n    m_drawing-&gt;draw();\n}\n</code></pre> <p>This abstraction allows for easy management of multiple layers and improves the overall organization of the code.</p> <pre><code>void ForcePadWindow::onDraw()\n{\n    ClearBackground(WHITE);\n\n    // Initiate render to current layer and texture\n\n    m_drawing-&gt;beginDraw();\n\n    // Pixel drawing operations to current layer.\n\n    m_drawing-&gt;endDraw();\n\n    m_drawing-&gt;updateMouse(mouseX(), mouseY());\n\n    // Draw all textures\n\n    m_drawing-&gt;draw();\n}\n</code></pre> <p>The Drawing draw() method is also relatively small.</p> <pre><code>void Drawing::draw()\n{\n    ...\n\n    for (auto &amp;layer : m_layers)\n    {\n        if (layer-&gt;visible())\n        {\n            layer-&gt;draw();\n        }\n    }\n\n    ...\n}\n</code></pre> <p>I was initially concerned about the performance impact of using screen-sized render textures. However, after testing it on various hardware, I was pleasantly surprised to find that it performs remarkably well. The application consistently maintains a smooth frame rate of 60 frames per second, even when multiple layers are used.</p>"},{"location":"blog/2024/08/21/the-conceptual-model-of-forcepad-3/#adding-vector-drawing","title":"Adding vector drawing","text":"<p>To improve precision when sketching, I decided to implement vector-based drawing in ForcePAD. RayLib provides many built-in functions for drawing basic shapes, making it a suitable choice as a base for drawing the shapes. To achieve this, I created an abstract class Shape to store generic attributes such as fill color, line color, and border thickness for vector shapes. Additionally, I implemented specific Shape classes like Ellipse, Rectangle, and Line to implement concreate drawing of the shapes.</p> <p>To avoid implementing a separate vector drawing mechanism, each Layer class maintains a set of shapes that are drawn on top of the render texture. As a result, the draw() method of the layer becomes responsible for rendering these shapes.</p> <pre><code>void graphics::Layer::draw()\n{\n    m_renderTexture-&gt;draw(0, 0, m_tint);\n\n    for (auto &amp;shape : m_shapes)\n    {\n        shape-&gt;draw();\n    }\n}\n</code></pre>"},{"location":"blog/2024/08/21/the-conceptual-model-of-forcepad-3/#a-first-verion-of-the-forcepad-model","title":"A first verion of the ForcePAD model","text":"<p>The Drawing class will serve as the foundation for implementing the ForcePAD model. It will be a layered model consisting of the following layers:</p> <ol> <li>Drawing layers: Manages pixel and vector shapes.</li> <li>Result layer: Contains the results from the simulated model.</li> <li>Force and constraints layer: Draws and maintains forces and constraints for the model.</li> </ol> <p>The class will handle interactions with shapes, pixels, forces, and constraints. It will also implement features such as hovering and selection. Additionally, the Drawing class will serve as the main data model for ForcePAD, allowing for serialization of the model to disk. The plan is to use JSON as the primary file format for ForcePAD, enabling easy reading and writing of models by other applications. The implementation of serialization will be done in a separate class.</p> <p>I am satisfied with the current model and it has been successfully implemented in the latest version of ForcePAD 3 on GitHub. No significant modifications have been necessary for the underlying model as of yet.</p>"},{"location":"blog/archive/2024/","title":"2024","text":""},{"location":"blog/category/calfem/","title":"CALFEM","text":""},{"location":"blog/category/python/","title":"Python","text":""},{"location":"blog/category/forcepad/","title":"ForcePAD","text":""},{"location":"blog/category/c/","title":"C++","text":""},{"location":"blog/category/concept/","title":"Concept","text":""},{"location":"blog/category/design/","title":"Design","text":""},{"location":"blog/category/backend/","title":"Backend","text":""},{"location":"blog/category/raylib/","title":"Raylib","text":""},{"location":"blog/category/cmake/","title":"CMake","text":""},{"location":"blog/category/vcpkg/","title":"vcpkg","text":""},{"location":"blog/category/multiplatform/","title":"Multiplatform","text":""}]}